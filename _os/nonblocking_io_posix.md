---
title: "Асинхронный неблокирующий ввод/вывод средствам POSIX"
subtitle: "Неблокирующий ввод/вывод в современных ОС позволяет обрабатывать десятки, сотни и даже тысячи одновременно открытых сетевых запросов либо файлов. Для этой цели не требуется создавать новые потоки, достаточно лишь запустить специальный цикл событий на одном потоке-обработчике"
---

> Материал основан на статье [Blocking I/O, Nonblocking I/O, And Epoll (англ.)](https://eklitzke.org/blocking-io-nonblocking-io-and-epoll)

В этой статье мы покажем, что именно происходит, когда вы используете неблокирующий ввод-вывод. Мы расмотрим:

* Смысл добавления флага `O_NONBLOCK` on для файловых дескрипторов с помощью `fcntl`
* Что означают понятия "неблокирующий", "асинхронный", "событийный" для ввода-вывода
* Почему неблокирующий ввод-вывод часто сочетается с мультиплексированием с помощью `select`, `epoll` и `kqueue`
* Как неблокирующий режим ввода-вывода взаимодействует со средствам опроса дескрипторов, такими как `epoll`

## Блокирующий режим

По умолчанию все файловые дескрипторы в Unix-системах создаются в "блокирующем" режиме. Это означает, что системные вызовы для ввода-вывода, такие как `read`, `write` или `connect`, могут заблокировать выполнение программы вплоть до готовности результата операции. Легче всего понять это на примере чтения данных из потока stdin в консольной программе. Как только вы вызываете `read` для stdin, выполнение программы блокируется, пока данные не будут введены пользователем с клавиатуры и затем прочитаны системой. То же самое происходит при вызове функций стандартной библиотеки, таких как `fread`, `getchar`, `std::getline`, поскольку все они в конечном счёте используют системный вызов `read`. Если говорить конкретнее, ядро погружает процесс в спящее состояние, пока данные не станут доступны в псевдо-файле stdin. То же самое происходит и для любых других файловых дескрипторов. Например, если вы пытаетесь читать из TCP-сокета, то `read` заблокирует выполнение, пока другая сторона TCP-соединения не пришлёт ответные данные.

Блокировки - это проблема для всех программ, требующих конкуррентного выполнения, поскольку заблокированные потоки процесса засыпают и не получают процессорное время. Существует два различных, но взаимодополняющих способа устранить блокировки:

- неблокирующий режим
- мультиплексирование ввода-вывода с помощью системных вызовов, например `select` либо `epoll`

Оба решения часто применяются совместно, но предоставляют разные стратегии решения проблемы. Скоро мы покажем разницу и объясним, почему их часто совмещают.

## Неблокирующий режим (O_NONBLOCK)

Файловый дескриптор помещают в "неблокирующий" режим, добавляя флаг `O_NONBLOCK` к существующему набору флагов дескриптора файла с помощью `fcntl`:

```cpp
/* Добавляем флаг O_NONBLOCK к дескриптору fd */
const int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);
```

Начиная с момента установки флага, файловый дескриптор становится неблокирующим. Любые системные вызовы для ввода-вывода, такие как `read` и `write`, которые ранее могли бы вызвать блокировку из-за неготовности данных, теперь будут возвращать `-1`, а глобальную переменную `errno` устанавливать в `EWOULDBLOCK`, Это интересное изменение поведения, но само по себе мало полезное: оно лишь является базовым примитивом для построения эффективной системы ввода-вывода для множества файловых дескрипторов.

Допустим, требуется параллельно прочитать целиком данные из двух файловых дескрипторов. Это может быть достигнуто с помощью цикла, который проверяет наличие данных в каждом файловом дескрипторе, а затем засыпает ненадолго перед новой проверкой:

```cpp
// Интервал сна: 1 микросекунда
const timespec sleep_interval{.tv_sec = 0, .tv_nsec = 1000};
ssize_t nbytes = 0;
for (;;) {
    // Проверяем, есть ли данные в fd1
    if ((nbytes = read(fd1, buf, sizeof(buf))) < 0) {
        if (errno != EWOULDBLOCK) {
            // TODO: обработать ошибку ввода-вывода
            perror("read");
            exit(EXIT_FAILURE);
        }
    } else {
        // Как-либо обрабатываем данные.
        handleData(buf, nbytes);
    }

    // Проверяем, есть ли данные в fd2
    if ((nbytes = read(fd2, buf, sizeof(buf))) < 0) {
        if (errno != EWOULDBLOCK) {
            // TODO: обработать ошибку ввода-вывода
            perror("read");
            exit(EXIT_FAILURE);
        }
    } else {
        // Как-либо обрабатываем данные.
        handleData(buf, nbytes);
    }

    // Засыпаем на короткое время
    nanosleep(sleep_interval, NULL);
}
```

Такой подход работает, но имеет свои минусы:

* Если данные приходят очень медленно, программа будет постоянно просыпаться и тратить впустую процессорное время
* Когда данные приходят, программа, возможно, не прочитает их сразу, т.к. выполнение приостановлено из-за `nanosleep`
* Увеличение интервала сна уменьшит бесполезные траты процессорного времени, но увеличит задержку обработки данных
* Увеличение числа файловых дескрипторов с таким же подходом к их обработке увеличит долю расходов на проверки наличия данных

Для решения этих проблем операционная система предоставляет мультиплексирование ввода-вывода.

## Мультиплексирование ввода-вывода (select, epoll, kqueue и т.д.)

Существует несколько мультиплексирующих системных вызовов:

- Вызов `select` существует во всех POSIX-совместимых системах, включая Linux и MacOSX
- [Группа вызовов epoll_*](https://www.opennet.ru/man.shtml?topic=epoll&category=4&russian=0) существует только на Linux
- [Группа вызовов kqueue](https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2) существует на FreeBSD и других *BSD

Все три варианта реализуют единый принцип: делегировать ядру задачу по отслеживанию прихода данных для операций чтения/записи над множеством файловых дескрипторов. Все варианты могут заблокировать выполнение, пока не произойдёт какого-либо события с одним из дескрипторов из указанного множества. Например, вы можете сообщить ядру ОС, что вас интересуют только события чтения для файлового дескриптора X, события чтения-записи для дескриптора Y, и только события записи - для Z.

Все мультиплексирующие системные вызовы, как правило, работают независимо от режима файлового дескриптора (блокирующего или неблокирующего). Программист может даже все файловые дескрипторы оставить блокирующими, и после `select` либо `epoll` возвращённые ими дескрипторы не будут блокировать выполнение при вызове `read` или `write`, потому что данные в них уже готовы. Есть важное исключение для `epoll`, о котором скажем далее.

## Как O_NONBLOCK сочетается с мультиплексером select

> Подробнее о `select` и `fd_set` читайте в [man-документации select](https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=select&category=2)

Допустим, мы пишем простую программу-daemon, обслуживающее клиентские приложения через сокеты. Мы воспользуемся мультиплексером `select` и блокирующими файловыми дескрипторами. Для простоты предположим, что мы уже открыли файлы и добавили их в переменную `read_fds`, имеющую тип `fd_set` (то есть "набор файлов"). Ключевым элементом цикла событий, обрабатывающего файл, будет вызов `select` и дальнейшие вызовы `read` для каждого из дескрипторов в наборе.

Тип данных `fd_set` представляет просто массив файловых дескрипторов, где с каждым дескриптором связан ещё и флаг (0 или 1). Примерно так могло бы выглядеть объявление:

```cpp
const size_t FD_SETSIZE = 1024; // Размер определён платформой.

struct fd_set {
  int fd[FD_SETSIZE]; // файловые дескрипторы
  short flags[FD_SETSIZE]; // флаги, можно считать за 0 или 1
  unsigned count; // число добавленных дескрипторов
};
```

Функция `select` принимает несколько объектов `fd_set`. В простейшем случае мы передаём один `fd_set` с набором файлов для чтения, а `select` модифицирует их, проставляя флаг для тех дескрипторов, из которых можно читать данные. Также функция возвращает число готовых для обработки файлов. Далее с помощью макроса `FD_ISSET(index, &set)` можно проверить, установлен ли флаг, т.е. можно ли читать данные без блокировки.

```
for (;;) {
    // Шаг 1: ожидание данных через вызов select
    if (select(FD_SETSIZE, &read_fds, NULL, NULL, NULL) < 0) {
        // TODO: обработать ошибку вызова select
        perror("select");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < FD_SETSIZE; i++) {
        if (FD_ISSET(i, &read_fds)) {
            // Шаг 2: чтение данных из каждого файла
            char buf[1024];
            const ssize_t nbytes = read(i, buf, sizeof(buf));
            if (nbytes >= 0) {
                // Как-либо обрабатываем данные.
                handleData(nbytes, buf);
            } else {
                // TODO: обработать ошибку ввода-вывода
                perror("read");
                exit(EXIT_FAILURE);
            }
        }
    }
}
```

Такой подход работает, но давайте предположим, что размер буфера `buf` очень маленький, а объём пакетов данных, читаемых из дескрипторов файлов, очень велик. Например, в примере выше размер `buf` всего 1024 байта, допустим что через сокеты приходят пакеты по 64КБ. Для обработки одного пакета потребуется 64 раза вызвать `select`, а затем 64 раза вызвать `read`. В итоге мы получим 128 системных вызовов, но каждый вызов приводит к одному переключению контекста между kernel и userspace, в итоге обработка пакета обходится дорого.

Можем ли мы уменьшить число вызовов `select`? В идеале, для обработки одного пакета мы хотели бы вызвать `select` только один раз. Чтобы сделать это, потребуется перевести все файловые дескрипторы в неблокирующий режим. Ключевая идея - вызывать `read` в цикле до тех пор, пока вы не получите код ошибки `EWOULDBLOCK`, обозначающий отсутствие новых данных в момент вызова. Идея реализована в примере:

```
for (;;) {
    /* select call happens here */
    if (select(FD_SETSIZE, &read_fds, NULL, NULL, NULL) < 0) {
        // TODO: обработать ошибку вызова select
        perror("select");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < FD_SETSIZE; i++) {
        if (FD_ISSET(i, &read_fds)) {
            /* НОВИНКА: крутим цикл, пока не получим EWOULDBLOCK */
            for (;;) {
                char buf[1024];
                const ssize_t nbytes = read(i, buf, sizeof(buf));
                if (nbytes >= 0) {
                    // Как-либо обрабатываем данные.
                    handle_read(nbytes, buf);
                } else {
                    if (errno != EWOULDBLOCK) {
                        // TODO: обработать код ошибки EINTR
                        perror("read");
                        exit(EXIT_FAILURE);
                    }
                    break;
                }
            }
        }
    }
}
```

В этом примере при наличии буфера в 1024 байта и входящего пакета в 64КБ мы получим 66 системных вызовов: `select` будет вызван один раз, а `read` будет вызываться 64 раза без каких-либо ошибок, а 65-й раз вернёт ошибку `EWOULDBLOCK`.

## Мультиплексер epoll в режиме edge-triggered

Группа вызовов epoll является наиболее развитым мультиплексером в ядре Linux и способна работать в двух режимах:

- level-triggered - похожий на `select` упрощённый режим, в котором файловый дескриптор возвращается, если остались непрочитанные данные
    - если приложение прочитало только часть доступных данных, вызов epoll вернёт ему недопрочитанные дескрипторы
- edge-triggered - файловый дескриптор с событием возвращается только если с момента последнего возврата epoll произошли новые события (например, пришли новые данные)
    - если приложение прочитало только часть доступных данных, в данном режиме оно всё равно будет заблокировано до прихода каких-либо новых данных

Чтобы глубже понять происходящее, рассмотрим схему работы epoll с точки зрения ядра. Допустим, приложение с помощью epoll начало мониторинг поступления данных для чтения из какого-либо файла. Для этого приложение вызывает `epoll_wait` и засыпает на этом вызове. Ядро хранит связь между ожидающими данных потоками и файловым дескриптором, который один или несколько потоков (или процессов) отслеживают. В случае поступления порции данных ядро обходит список ожидающих потоков и разблокирует их, что для потока выглядит как возврат из функции `epoll_wait`.

- В случае level-triggered режима вызов `epoll_wait` пройдёт по списку файловых дескрипторов и проверит, не соблюдается ли в данный момент условие, которое интересует приложение, что может привести к возврату из `epoll_wait` без какой-либо блокировки.
- В случае edge-triggered режима ядро пропускает такую проверку и усыпляет поток, пока не обнаружит событие прихода данных на одном из файловых дескрипторов, за которыми следит поток. Такой режим  превращает `epoll` в мультиплексер с алгоритмической сложностью O(1): после прихода новых данных из файла ядро сразу же знает, какой процесс надо пробудить.

Для использования edge-triggered режима нужно поместить файловые дескрипторы в неблокирующий режим, и на каждой итерации вызывать `read` либо `write` до тех пор, пока они не установят код ошибки `EWOULDBLOCK`. Вызов `epoll_wait` будет более эффективным благодаря мгновенному засыпанию потока, и это крайне важно для программ с огромным числом конкурирующих файловых дескрипторов, например, для HTTP-серверов.

- Ищите справку в [man-документации для epoll](https://www.opennet.ru/man.shtml?topic=epoll&category=4&russian=0)
- Полный пример с использованием epoll есть на [github.com/eklitzke/epollet](https://github.com/eklitzke/epollet)
