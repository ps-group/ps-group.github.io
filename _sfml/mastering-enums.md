---
title: "Искусство владения enum в C++"
---

В играх многие объекты имеют состояния: персонажи двигаются, прыгают, борются или умирают; артефакты появляются и затем манят игрока спецэффектами; заклинания колдуются, летят к цели и в конце воздействуют на неё.

![Иллюстрация](img/hero-states-demo.png)

Здесь программисту важны два аспекта:

- процессы (смена спрайтов, анимации, звуковые эффекты)
- состояния (поведение и выбор анимации/звуков)

Для процессов фреймворк предоставляет готовые средства, такие как [cocos2d::Animation](www.cocos2d-x.org/wiki/Sprite_Sheet_Animation) или [CocosDenshion::SimpleAudioEngine](http://www.cocos2d-x.org/reference/native-cpp/V3.3rc0/de/d8f/class_cocos_denshion_1_1_simple_audio_engine.html). Для состояний готовое решение сделать почти невозможно — и программисту следует реализовать их самостоятельно. Простейший способ — дать каждому процессу идентификатор, например, число.

```cpp
switch (m_state)
{
case 0:
    // idle state
    break;
case 1:
    // walking state
    break;
case 2:
    // attacking state
    break;
}
```

## От числа к enum

- В целях замены магических чисел на константы можно дать константам имена, но тогда они всё равно будут выглядеть независимыми значениями. Чтобы подчеркнуть их связанность, можно использовать enum.
- Объектно-ориентированный подход имеет и другие решения этой проблемы, но они требуют введения новых вспомогательных классов и применения расширенных возможностей C++. Для реализации простого персонажа в игре всё это излишнее.

```cpp
// enum "загрязняет" внешнее пространтсво имён, зато может быть неявно приведён к int
// enum class не загрязняет внешнее пространтсво имён, но требует явных приведений к int вместо неявных
enum class UnitState
{
    IDLE,
    WALKING,
    ATTACKING, // запятая на последней строке полезна, чтобы уменьшить число изменяемых строк в git.
};

switch (m_state)
{
case UnitState::IDLE:
    break;
case UnitState::WALKING:
    break;
case UnitState::ATTACKING:
    break;
}
const int numericState = static_cast<int>(m_state);
```

## enum + map

В хорошей игре состоянию соответствует целая анимация, а не один статичный спрайт. Анимация — серия сменяемых кадров, она занимает определённый интервал времени (но может быть зациклена). При переключении состояния следует менять анимацию. Хранение анимаций, связанных с состоянием, можно реализовать с помощью ассоциативного контейнера:

```cpp
// Базовый класс для юнитов игры
class CPuppet : cocos2d::Node
{
public:
    // public interface here.
private:
    // Мы используем map и оборачиваем анимации в RefPtr, чтобы держать сильные ссылки
    // на них и не допускать удаления. Другой способ — использовать класс cocos2d::Map,
    // который хранит ссылку сам без дополнительного оборачивания в RefPtr.
    std::map<UnitState, cocos2d::RefPtr<cocos2d::Animation>> m_stateAnimations;
};
```

Тип `std::map` предоставляет:

- метод `.at(key)` сложности O(log(size)) для получения ссылки на элемент (бросает `std::out_of_range`, если ключ не найден)
- оператор `.[key]` сложности O(log(size)) для получения ссылки на элемент (создаёт новый элемент, если ключ не найден)
- метод `.count(key)` сложноти O(log(size)), возвращающий 1 при наличии ключа и 0 при отсутствии
- и другие привычные методы и свойства контейнеров STL

## Наследование enum

Допустим, в вашей игре каждый юнит имеет как минимум три состояния: стоит на месте, бежит, прыгает.

- Логика обработки трёх состояний находится в классе `CPuppet`
- Фреймы для трёх анимаций состояний передаются снаружи через `protected`-метод `CPuppet::SetAnimation(UnitState state, cocos2d::Animation *animation)`

Возникает проблема: у игрока есть дополнительные состояния атаки и колдовства, и класс `CPlayer`, расширяющий `CPuppet`, должен иметь 5 состояний вместо 3-х. Но `enum class UnitState` уже объявлен.

Для этого enum надо "унаследовать". Чтобы сделать это, вспомним синтаксис enum:
```
'enum' IDENTIFIER
'{'
    CONSTANT ['=' VALUE] ','
    CONSTANT ['=' VALUE] ','
    CONSTANT ['=' VALUE] [',']
'}' ';'
```
Вы можете задать значение каждой константы enum явно, а можете не задавать — тогда значение будет равно значению предыдущей константы плюс один:
```cpp
enum class UnitState
{
    IDLE = 0, // значение явно задано: 0
    WALKING, // значение на 1 больше предыдущего: 1
    JUMPING, // значение на 1 больше предыдущего: 2
};

enum class PlayerOnlyState
{
    ATTACKING = static_cast<int>(UnitState::JUMPING) + 1, // значение явно задано: 3
    CASTING, // значение на 1 больше предыдущего: 4
};
```

При использовании `std::map`, следует предпочитать `std::map<int, cocos2d::RefPtr<cocos2d::Animation>>`, а не `std::map<UnitState, cocos2d::RefPtr<cocos2d::Animation>>`

## Неявное приведение scoped enum к int

Можно получить практически аналог `enum class`, но с возможностью неявного приведения к int:
```cpp
struct UnitState
{
    enum Value
    {
        IDLE,
        WALKING,
        JUMPING,
        LAST_VALUE = JUMPING
    };
};
// теперь состояния доступны как UnitState::IDLE и т.д.

struct PlayerOnlyState
{
    enum Value
    {
        ATTACKING = UnitState::LAST_VALUE + 1,
        CASTING,
    };
};
// специфичные состояния игрока доступны как PlayerOnlyState::CASTING и т.д.
```
